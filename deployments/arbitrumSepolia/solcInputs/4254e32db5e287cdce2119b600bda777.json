{
  "language": "Solidity",
  "sources": {
    "contracts/DAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPool {\r\n    function approveClaim(uint256 claimId) external;\r\n    function rejectClaim(uint256 claimId) external;\r\n    function getCoverage(address user) external view returns (uint256);\r\n    function premiumsPaid(address user) external view returns (uint256);\r\n    function totalPremiums() external view returns (uint256);\r\n}\r\n\r\ncontract DAO {\r\n    struct Member {\r\n        uint256 premiumWeight;\r\n        bool isMember;\r\n    }\r\n\r\n    struct Proposal {\r\n        uint256 claimId;\r\n        int256 totalVotes;\r\n        uint256 endTime;\r\n        bool executed;\r\n        address proposer;\r\n    }\r\n\r\n    mapping(address => Member) public members;\r\n    mapping(uint256 => Proposal) public proposals;\r\n    uint256 public proposalCounter;\r\n    uint256 public minimumQuorum = 20;\r\n    uint256 public votingDuration = 3 days;\r\n\r\n    address public poolContract;\r\n\r\n    event ProposalCreated(uint256 indexed proposalId, uint256 claimId, address proposer);\r\n    event VoteCast(uint256 indexed proposalId, address voter, bool support, uint256 weight);\r\n    event ProposalExecuted(uint256 indexed proposalId, bool approved);\r\n\r\n    constructor(address _poolContract) {\r\n        poolContract = _poolContract;\r\n    }\r\n\r\n    function joinDAO(address user, uint256 premiumWeight) external {\r\n        members[user] = Member({\r\n            premiumWeight: premiumWeight,\r\n            isMember: true\r\n        });\r\n    }\r\n\r\n    function proposeClaim(uint256 claimId) external {\r\n        proposalCounter++;\r\n        proposals[proposalCounter] = Proposal({\r\n            claimId: claimId,\r\n            totalVotes: 0,\r\n            endTime: block.timestamp + votingDuration,\r\n            executed: false,\r\n            proposer: msg.sender\r\n        });\r\n\r\n        emit ProposalCreated(proposalCounter, claimId, msg.sender);\r\n    }\r\n\r\n    function vote(uint256 proposalId, bool support) external {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(block.timestamp < proposal.endTime, \"Voting ended\");\r\n        require(!proposal.executed, \"Already executed\");\r\n\r\n        uint256 weight = members[msg.sender].premiumWeight;\r\n        proposal.totalVotes += support ? int256(weight) : -int256(weight);\r\n\r\n        emit VoteCast(proposalId, msg.sender, support, weight);\r\n    }\r\n\r\n    function executeProposal(uint256 proposalId) external {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(block.timestamp >= proposal.endTime, \"Voting ongoing\");\r\n        require(!proposal.executed, \"Already executed\");\r\n\r\n        proposal.executed = true;\r\n\r\n        if (proposal.totalVotes > 0) {\r\n            IPool(poolContract).approveClaim(proposal.claimId);\r\n        } else {\r\n            IPool(poolContract).rejectClaim(proposal.claimId);\r\n        }\r\n\r\n        emit ProposalExecuted(proposalId, proposal.totalVotes > 0);\r\n    }\r\n}\r\n"
    },
    "contracts/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Pool {\r\n    struct Plan {\r\n        uint256 id;\r\n        string name;\r\n        uint256 premium; // Monthly premium in wei\r\n        uint256 coverageAmount; // Coverage amount in wei\r\n    }\r\n\r\n    struct Claim {\r\n        address claimant;\r\n        uint256 amount;\r\n        uint256 unlockTime;\r\n        ClaimStatus status;\r\n        string evidenceURI;\r\n        bool exists;\r\n    }\r\n\r\n    struct Staker {\r\n        uint256 balance;\r\n        uint256 lastStakeTime;\r\n        uint256 lockDuration;\r\n    }\r\n\r\n    struct User {\r\n        uint256 totalPremiumPaid;\r\n        uint256 coverage; // Coverage based on selected plan\r\n    }\r\n\r\n    enum ClaimStatus { Timelock, DAO_Voting, Claimed, Rejected }\r\n\r\n    mapping(address => User) public users; // User contributions\r\n    mapping(address => Staker) public stakers; // User stakes\r\n    mapping(uint256 => Claim) public claims; // Claims tracking\r\n    uint256 public claimCounter;\r\n    uint256 public totalPremiums; // Total premiums pool\r\n    uint256 public totalStaked; // Total staked pool\r\n\r\n    Plan[] public plans;\r\n\r\n    uint256 public constant CLAIM_TIME_LOCK = 2 days;\r\n\r\n    // Events\r\n    event PremiumPaid(address indexed user, uint256 amount, uint256 coverage);\r\n    event ClaimInitiated(\r\n        uint256 claimId,\r\n        address indexed claimant,\r\n        uint256 amount,\r\n        uint256 unlockTime,\r\n        string evidenceURI\r\n    );\r\n    event ClaimApproved(uint256 claimId, address indexed claimant, uint256 amount);\r\n    event ClaimRejected(uint256 claimId);\r\n    event StakeDeposited(address indexed user, uint256 amount, uint256 lockDuration);\r\n    event StakeWithdrawn(address indexed user, uint256 amount, bool withInterest);\r\n\r\n    constructor() {\r\n        _addPlan(\"Basic Shield\", 0.01 ether, 5 ether);\r\n        _addPlan(\"Premium Guard\", 0.02 ether, 10 ether);\r\n        _addPlan(\"Ultimate Protection\", 0.03 ether, 20 ether);\r\n    }\r\n\r\n    // Add insurance plan\r\n    function _addPlan(string memory name, uint256 premium, uint256 coverageAmount) internal {\r\n        plans.push(Plan({\r\n            id: plans.length,\r\n            name: name,\r\n            premium: premium,\r\n            coverageAmount: coverageAmount\r\n        }));\r\n    }\r\n\r\n    // Pay premium and set coverage\r\n    function payPremium(uint256 planId) external payable {\r\n        require(planId < plans.length, \"Invalid plan ID\");\r\n        Plan memory plan = plans[planId];\r\n        require(msg.value == plan.premium, \"Incorrect premium amount\");\r\n\r\n        User storage user = users[msg.sender];\r\n        user.totalPremiumPaid += msg.value;\r\n        user.coverage = plan.coverageAmount;\r\n        totalPremiums += msg.value;\r\n\r\n        emit PremiumPaid(msg.sender, msg.value, plan.coverageAmount);\r\n    }\r\n\r\n    // Stake tokens with lock duration\r\n    function stakeTokens(uint256 amount, uint256 duration) external payable {\r\n        require(amount > 0, \"Stake amount must be greater than zero\");\r\n        require(duration == 30 days || duration == 180 days || duration == 365 days, \"Invalid lock duration\");\r\n\r\n        Staker storage staker = stakers[msg.sender];\r\n        staker.balance += amount;\r\n        staker.lastStakeTime = block.timestamp;\r\n        staker.lockDuration = duration;\r\n\r\n        totalStaked += amount;\r\n\r\n        emit StakeDeposited(msg.sender, amount, duration);\r\n    }\r\n\r\n    // Withdraw staked tokens\r\n    function withdrawStake() external {\r\n        Staker storage staker = stakers[msg.sender];\r\n        require(staker.balance > 0, \"No stake to withdraw\");\r\n\r\n        uint256 amount = staker.balance;\r\n        bool withInterest = block.timestamp >= staker.lastStakeTime + staker.lockDuration;\r\n\r\n        staker.balance = 0;\r\n        totalStaked -= amount;\r\n\r\n        uint256 payout = withInterest ? amount + _calculateInterest(amount, staker.lockDuration) : amount;\r\n        payable(msg.sender).transfer(payout);\r\n\r\n        emit StakeWithdrawn(msg.sender, payout, withInterest);\r\n    }\r\n\r\n    function _calculateInterest(uint256 amount, uint256 duration) internal pure returns (uint256) {\r\n        if (duration == 30 days) return (amount * 3) / 1000; // 0.3%\r\n        if (duration == 180 days) return (amount * 20) / 1000; // 2%\r\n        if (duration == 365 days) return (amount * 50) / 1000; // 5%\r\n        return 0;\r\n    }\r\n\r\n    // Initiate a claim\r\n    function initiateClaim(uint256 amount, string calldata evidenceURI) external returns (uint256) {\r\n        require(amount > 0, \"Claim amount must be greater than zero\");\r\n        require(users[msg.sender].coverage >= amount, \"Claim exceeds coverage\");\r\n\r\n        claimCounter++;\r\n        uint256 unlockTime = block.timestamp + CLAIM_TIME_LOCK;\r\n\r\n        claims[claimCounter] = Claim({\r\n            claimant: msg.sender,\r\n            amount: amount,\r\n            unlockTime: unlockTime,\r\n            status: ClaimStatus.Timelock,\r\n            evidenceURI: evidenceURI,\r\n            exists: true\r\n        });\r\n\r\n        emit ClaimInitiated(claimCounter, msg.sender, amount, unlockTime, evidenceURI);\r\n        return claimCounter;\r\n    }\r\n\r\n    // Approve claim\r\n    function approveClaim(uint256 claimId) external {\r\n        Claim storage claim = claims[claimId];\r\n        require(claim.exists, \"Claim does not exist\");\r\n        require(claim.status == ClaimStatus.Timelock, \"Invalid claim status\");\r\n        require(block.timestamp >= claim.unlockTime, \"Claim in timelock\");\r\n\r\n        claim.status = ClaimStatus.Claimed;\r\n        require(totalPremiums >= claim.amount, \"Insufficient premiums\");\r\n        totalPremiums -= claim.amount;\r\n\r\n        emit ClaimApproved(claimId, claim.claimant, claim.amount);\r\n    }\r\n\r\n    // Reject claim\r\n    function rejectClaim(uint256 claimId) external {\r\n        Claim storage claim = claims[claimId];\r\n        require(claim.exists, \"Claim does not exist\");\r\n\r\n        claim.status = ClaimStatus.Rejected;\r\n        emit ClaimRejected(claimId);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}