{
  "language": "Solidity",
  "sources": {
    "contracts/DAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPool {\r\n    function approveClaim(uint256 claimId) external;\r\n    function rejectClaim(uint256 claimId) external;\r\n    function getStakeWeight(address user) external view returns (uint256);\r\n}\r\n\r\ncontract DAO {\r\n    struct Member {\r\n        uint256 premiumWeight; // Voting weight based on premiums paid\r\n        bool isMember;\r\n    }\r\n\r\n    struct Proposal {\r\n        uint256 claimId;\r\n        int256 totalVotes; // Sum of positive (YES) and negative (NO) votes\r\n        uint256 endTime;\r\n        bool executed;\r\n        address proposer; // Address that created the proposal\r\n    }\r\n\r\n    mapping(address => Member) public members; // DAO members\r\n    mapping(uint256 => Proposal) public proposals; // Track proposals\r\n    uint256 public proposalCounter;\r\n    uint256 public minimumQuorum = 20; // Minimum quorum percentage\r\n    uint256 public votingDuration = 3 days; // Duration for voting\r\n    uint256 public proposalFee = 0.01 ether; // Fee for manually proposing a claim\r\n\r\n    address public poolContract; // Address of the Insurance Pool contract\r\n    address public aiProcessor; // Authorized AI processor address\r\n\r\n    // Events\r\n    event MemberJoined(address indexed member, uint256 premiumWeight);\r\n    event ProposalCreated(uint256 indexed proposalId, uint256 claimId, address proposer, uint256 endTime);\r\n    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support, uint256 weight);\r\n    event ProposalExecuted(uint256 indexed proposalId, bool approved);\r\n    event AIProcessorUpdated(address newAIProcessor);\r\n    event ProposalFeeUpdated(uint256 newFee);\r\n\r\n    // Modifiers\r\n    modifier onlyMember() {\r\n        require(members[msg.sender].isMember, \"Only DAO members can perform this action\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAIProcessor() {\r\n        require(msg.sender == aiProcessor, \"Only the AI processor can perform this action\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _poolContract) {\r\n        poolContract = _poolContract;\r\n        aiProcessor = msg.sender; // Initially set the deployer as the AI processor\r\n    }\r\n\r\n    // Add a member to the DAO\r\n    function joinDAO(address member, uint256 premiumWeight) external {\r\n        require(!members[member].isMember, \"Already a DAO member\");\r\n        members[member] = Member({ premiumWeight: premiumWeight, isMember: true });\r\n        emit MemberJoined(member, premiumWeight);\r\n    }\r\n\r\n    // Propose a claim automatically after AI approval\r\n    function proposeClaimAI(uint256 claimId) external onlyAIProcessor {\r\n        proposalCounter++;\r\n        proposals[proposalCounter] = Proposal({\r\n            claimId: claimId,\r\n            totalVotes: 0,\r\n            endTime: block.timestamp + votingDuration,\r\n            executed: false,\r\n            proposer: msg.sender\r\n        });\r\n\r\n        emit ProposalCreated(proposalCounter, claimId, msg.sender, block.timestamp + votingDuration);\r\n    }\r\n\r\n    // Propose a claim manually by paying a fee\r\n    function proposeClaimManual(uint256 claimId) external payable onlyMember {\r\n        require(msg.value == proposalFee, \"Incorrect proposal fee\");\r\n\r\n        proposalCounter++;\r\n        proposals[proposalCounter] = Proposal({\r\n            claimId: claimId,\r\n            totalVotes: 0,\r\n            endTime: block.timestamp + votingDuration,\r\n            executed: false,\r\n            proposer: msg.sender\r\n        });\r\n\r\n        emit ProposalCreated(proposalCounter, claimId, msg.sender, block.timestamp + votingDuration);\r\n    }\r\n\r\n    // Vote on a proposal\r\n    function vote(uint256 proposalId, bool support) external onlyMember {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(block.timestamp < proposal.endTime, \"Voting period has ended\");\r\n        require(!proposal.executed, \"Proposal already executed\");\r\n\r\n        uint256 premiumWeight = members[msg.sender].premiumWeight;\r\n        uint256 stakeWeight = IPool(poolContract).getStakeWeight(msg.sender);\r\n        uint256 totalWeight = premiumWeight + stakeWeight;\r\n\r\n        // Add or subtract weight based on the vote\r\n        if (support) {\r\n            proposal.totalVotes += int256(totalWeight);\r\n        } else {\r\n            proposal.totalVotes -= int256(totalWeight);\r\n        }\r\n\r\n        emit VoteCast(proposalId, msg.sender, support, totalWeight);\r\n    }\r\n\r\n    // Execute the proposal after voting ends\r\n    function executeProposal(uint256 proposalId) external {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(block.timestamp >= proposal.endTime, \"Voting period not ended\");\r\n        require(!proposal.executed, \"Proposal already executed\");\r\n\r\n        // Ensure quorum is met\r\n        require(\r\n            uint256(proposal.totalVotes > 0 ? proposal.totalVotes : -proposal.totalVotes) >= (getTotalVotingWeight() * minimumQuorum) / 100,\r\n            \"Quorum not reached\"\r\n        );\r\n\r\n        if (proposal.totalVotes > 0) {\r\n            // Approve the claim\r\n            IPool(poolContract).approveClaim(proposal.claimId);\r\n        } else {\r\n            // Reject the claim\r\n            IPool(poolContract).rejectClaim(proposal.claimId);\r\n        }\r\n\r\n        proposal.executed = true;\r\n        emit ProposalExecuted(proposalId, proposal.totalVotes > 0);\r\n    }\r\n\r\n    // Calculate the total voting weight\r\n    function getTotalVotingWeight() public view returns (uint256) {\r\n        uint256 totalWeight = 0;\r\n        for (uint256 i = 1; i <= proposalCounter; i++) {\r\n            if (!proposals[i].executed) {\r\n                totalWeight += uint256(proposals[i].totalVotes > 0 ? proposals[i].totalVotes : -proposals[i].totalVotes);\r\n            }\r\n        }\r\n        return totalWeight;\r\n    }\r\n\r\n    // Update AI processor address\r\n    function setAIProcessor(address newAIProcessor) external onlyAIProcessor {\r\n        aiProcessor = newAIProcessor;\r\n        emit AIProcessorUpdated(newAIProcessor);\r\n    }\r\n\r\n    // Update proposal fee\r\n    function updateProposalFee(uint256 newFee) external onlyAIProcessor {\r\n        proposalFee = newFee;\r\n        emit ProposalFeeUpdated(newFee);\r\n    }\r\n}\r\n"
    },
    "contracts/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Pool {\r\n    struct Claim {\r\n        address claimant;\r\n        uint256 amount;\r\n        uint256 unlockTime;\r\n        ClaimStatus status;\r\n        bool exists;\r\n    }\r\n\r\n    struct Staker {\r\n        uint256 balance;\r\n        uint256 lastStakeTime;\r\n        uint256 lockDuration; // Chosen lock-up period\r\n    }\r\n\r\n    enum ClaimStatus { Timelock, DAO_Voting, Claimed, Rejected }\r\n\r\n    mapping(address => uint256) public premiumsPaid; // Track premiums paid by each user\r\n    mapping(address => Staker) public stakers; // Track staking balances\r\n    mapping(uint256 => Claim) public claims; // Track claims\r\n    uint256 public claimCounter;\r\n    uint256 public totalPremiums; // Total premium pool\r\n    uint256 public totalStaked; // Total staked pool\r\n\r\n    // Fixed durations and interest rates for staking\r\n    uint256 public constant ONE_MONTH = 30 days;\r\n    uint256 public constant SIX_MONTHS = 180 days;\r\n    uint256 public constant ONE_YEAR = 365 days;\r\n\r\n    uint256 public constant ONE_MONTH_RATE = 3; // 0.3%\r\n    uint256 public constant SIX_MONTHS_RATE = 20; // 2%\r\n    uint256 public constant ONE_YEAR_RATE = 50; // 5%\r\n\r\n    // Fixed claim time lock duration\r\n    uint256 public constant CLAIM_TIME_LOCK = 2 days;\r\n\r\n    // Events\r\n    event PremiumPaid(address indexed user, uint256 amount);\r\n    event TokensStaked(address indexed staker, uint256 amount, uint256 lockTime, uint256 duration);\r\n    event StakeWithdrawn(address indexed staker, uint256 amount, bool interestEarned);\r\n    event ClaimInitiated(uint256 claimId, address indexed claimant, uint256 amount, uint256 unlockTime);\r\n    event ClaimCancelled(uint256 claimId);\r\n    event ClaimApproved(uint256 claimId, address indexed claimant, uint256 amount);\r\n    event ClaimRejected(uint256 claimId);\r\n\r\n    // Premium payment function\r\n    function payPremium(uint256 amount) external {\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        premiumsPaid[msg.sender] += amount;\r\n        totalPremiums += amount;\r\n        emit PremiumPaid(msg.sender, amount);\r\n    }\r\n\r\n    // Stake tokens with a chosen lock-up period\r\n    function stakeTokens(uint256 amount, uint256 duration) external {\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        require(duration == ONE_MONTH || duration == SIX_MONTHS || duration == ONE_YEAR, \"Invalid duration\");\r\n\r\n        stakers[msg.sender].balance += amount;\r\n        stakers[msg.sender].lastStakeTime = block.timestamp;\r\n        stakers[msg.sender].lockDuration = duration;\r\n        totalStaked += amount;\r\n\r\n        uint256 lockTime = block.timestamp + duration;\r\n        emit TokensStaked(msg.sender, amount, lockTime, duration);\r\n    }\r\n\r\n    // Withdraw staked tokens after lock-up period\r\n    function withdrawStake(uint256 amount) external {\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        require(stakers[msg.sender].balance >= amount, \"Insufficient balance\");\r\n\r\n        Staker storage staker = stakers[msg.sender];\r\n        bool interestEarned = block.timestamp >= staker.lastStakeTime + staker.lockDuration;\r\n\r\n        if (interestEarned) {\r\n            // Add interest to the user's withdrawal amount\r\n            uint256 interestRate = getInterestRate(staker.lockDuration);\r\n            uint256 interest = (amount * interestRate) / 1000;\r\n            staker.balance -= amount;\r\n            totalStaked -= amount;\r\n\r\n            emit StakeWithdrawn(msg.sender, amount + interest, true);\r\n        } else {\r\n            // Forfeit interest\r\n            staker.balance -= amount;\r\n            totalStaked -= amount;\r\n\r\n            emit StakeWithdrawn(msg.sender, amount, false);\r\n        }\r\n    }\r\n\r\n    // Get interest rate based on lock-up duration\r\n    function getInterestRate(uint256 duration) public pure returns (uint256) {\r\n        if (duration == ONE_MONTH) return ONE_MONTH_RATE;\r\n        if (duration == SIX_MONTHS) return SIX_MONTHS_RATE;\r\n        if (duration == ONE_YEAR) return ONE_YEAR_RATE;\r\n        return 0;\r\n    }\r\n\r\n    // Initiate a claim with time lock\r\n    function initiateClaim(address claimant, uint256 amount) external returns (uint256) {\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        require(premiumsPaid[claimant] > 0, \"User must pay a premium to initiate a claim\");\r\n\r\n        uint256 unlockTime = block.timestamp + CLAIM_TIME_LOCK;\r\n        claimCounter++;\r\n\r\n        claims[claimCounter] = Claim({\r\n            claimant: claimant,\r\n            amount: amount,\r\n            unlockTime: unlockTime,\r\n            status: ClaimStatus.Timelock,\r\n            exists: true\r\n        });\r\n\r\n        emit ClaimInitiated(claimCounter, claimant, amount, unlockTime);\r\n        return claimCounter;\r\n    }\r\n\r\n    // Approve the claim after DAO voting\r\n    function approveClaim(uint256 claimId) external {\r\n        Claim storage claim = claims[claimId];\r\n        require(claim.exists, \"Claim does not exist\");\r\n        require(block.timestamp >= claim.unlockTime, \"Claim is still in timelock\");\r\n        require(claim.status == ClaimStatus.Timelock, \"Claim not in timelock status\");\r\n\r\n        claim.status = ClaimStatus.Claimed;\r\n\r\n        // Deduct claim amount from the premium pool\r\n        require(totalPremiums >= claim.amount, \"Insufficient funds in the pool\");\r\n        totalPremiums -= claim.amount;\r\n\r\n        emit ClaimApproved(claimId, claim.claimant, claim.amount);\r\n    }\r\n\r\n    // Reject the claim during DAO voting\r\n    function rejectClaim(uint256 claimId) external {\r\n        Claim storage claim = claims[claimId];\r\n        require(claim.exists, \"Claim does not exist\");\r\n        require(claim.status == ClaimStatus.Timelock || claim.status == ClaimStatus.DAO_Voting, \"Claim cannot be rejected\");\r\n\r\n        claim.status = ClaimStatus.Rejected;\r\n        emit ClaimRejected(claimId);\r\n    }\r\n\r\n    // Cancel the claim before execution\r\n    function cancelClaim(uint256 claimId) external {\r\n        Claim storage claim = claims[claimId];\r\n        require(claim.exists, \"Claim does not exist\");\r\n        require(claim.status == ClaimStatus.Timelock, \"Claim cannot be cancelled at this stage\");\r\n\r\n        claim.status = ClaimStatus.Rejected;\r\n        emit ClaimCancelled(claimId);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}