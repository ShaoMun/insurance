{
  "language": "Solidity",
  "sources": {
    "contracts/DAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Pool.sol\";\r\n\r\ncontract DAO {\r\n    Pool public immutable pool;\r\n    \r\n    struct Proposal {\r\n        int256 totalVotes;\r\n        bool exists;\r\n        uint256 aiConfidence;\r\n        string evidenceURI;\r\n        uint256 yesVotes;\r\n        uint256 noVotes;\r\n        uint256 timestamp;\r\n        uint256 timelockEnd;\r\n        bool isAppealProposal;\r\n        mapping(address => bool) hasVoted;\r\n    }\r\n\r\n    uint256 public activeProposalCount;\r\n    mapping(uint256 => Proposal) public proposals;\r\n    \r\n    uint256 public constant VOTING_DURATION = 3 days;\r\n    uint256 public constant TIMELOCK_DURATION = 2 days;\r\n    uint256 public constant QUORUM_PERCENTAGE = 51;\r\n    uint256 public constant AI_APPROVAL_THRESHOLD = 60;\r\n    uint256 public appealFee = 0.1 ether;\r\n\r\n    event ProposalCreated(\r\n        uint256 indexed claimId,\r\n        string evidenceURI,\r\n        uint256 aiConfidence,\r\n        uint256 timestamp,\r\n        bool isAppeal\r\n    );\r\n    \r\n    event AppealSubmitted(\r\n        uint256 indexed claimId,\r\n        address indexed appellant,\r\n        uint256 appealFee\r\n    );\r\n\r\n    event VoteSubmitted(\r\n        uint256 indexed claimId,\r\n        address indexed voter,\r\n        bool vote,\r\n        uint256 votingPower\r\n    );\r\n    \r\n    event ProposalExecuted(\r\n        uint256 indexed claimId,\r\n        bool approved,\r\n        uint256 finalYesVotes,\r\n        uint256 finalNoVotes\r\n    );\r\n\r\n    constructor(address payable _poolAddress) {\r\n        pool = Pool(_poolAddress);\r\n    }\r\n\r\n    function createProposal(\r\n        uint256 claimId,\r\n        string memory evidenceURI,\r\n        uint256 aiConfidence\r\n    ) external {\r\n        require(msg.sender == address(pool), \"Only pool can create proposals\");\r\n        require(!proposals[claimId].exists, \"Proposal already exists\");\r\n        require(aiConfidence >= AI_APPROVAL_THRESHOLD, \"AI confidence too low\");\r\n\r\n        activeProposalCount++;\r\n\r\n        Proposal storage newProposal = proposals[claimId];\r\n        newProposal.exists = true;\r\n        newProposal.aiConfidence = aiConfidence;\r\n        newProposal.evidenceURI = evidenceURI;\r\n        newProposal.timestamp = block.timestamp;\r\n        newProposal.timelockEnd = block.timestamp + TIMELOCK_DURATION;\r\n        newProposal.isAppealProposal = false;\r\n\r\n        emit ProposalCreated(\r\n            claimId,\r\n            evidenceURI,\r\n            aiConfidence,\r\n            block.timestamp,\r\n            false\r\n        );\r\n    }\r\n\r\n    function submitAppeal(\r\n        uint256 claimId,\r\n        string memory evidenceURI,\r\n        uint256 aiConfidence\r\n    ) external payable {\r\n        require(!proposals[claimId].exists, \"Proposal already exists\");\r\n        require(aiConfidence < AI_APPROVAL_THRESHOLD, \"AI confidence too high\");\r\n        require(msg.value >= appealFee, \"Insufficient appeal fee\");\r\n\r\n        (bool success, ) = address(pool).call{value: msg.value}(\"\");\r\n        require(success, \"Fee transfer failed\");\r\n\r\n        activeProposalCount++;\r\n\r\n        Proposal storage newProposal = proposals[claimId];\r\n        newProposal.exists = true;\r\n        newProposal.aiConfidence = aiConfidence;\r\n        newProposal.evidenceURI = evidenceURI;\r\n        newProposal.timestamp = block.timestamp;\r\n        newProposal.timelockEnd = block.timestamp + TIMELOCK_DURATION;\r\n        newProposal.isAppealProposal = true;\r\n\r\n        emit AppealSubmitted(claimId, msg.sender, msg.value);\r\n        emit ProposalCreated(\r\n            claimId,\r\n            evidenceURI,\r\n            aiConfidence,\r\n            block.timestamp,\r\n            true\r\n        );\r\n    }\r\n\r\n    function submitVote(uint256 claimId, bool vote) external {\r\n        Proposal storage proposal = proposals[claimId];\r\n        require(proposal.exists, \"Proposal does not exist\");\r\n        require(!proposal.hasVoted[msg.sender], \"Already voted\");\r\n        require(\r\n            block.timestamp <= proposal.timelockEnd,\r\n            \"Timelock period ended\"\r\n        );\r\n\r\n        uint256 votingPower = calculateVotingPower(msg.sender);\r\n        require(votingPower > 0, \"No voting power\");\r\n\r\n        if (vote) {\r\n            proposal.yesVotes += votingPower;\r\n            proposal.totalVotes += int256(votingPower);\r\n        } else {\r\n            proposal.noVotes += votingPower;\r\n            proposal.totalVotes -= int256(votingPower);\r\n        }\r\n\r\n        proposal.hasVoted[msg.sender] = true;\r\n\r\n        emit VoteSubmitted(claimId, msg.sender, vote, votingPower);\r\n    }\r\n\r\n    function executeProposal(uint256 claimId) public {\r\n        Proposal storage proposal = proposals[claimId];\r\n        require(proposal.exists, \"Proposal does not exist\");\r\n        require(block.timestamp >= proposal.timelockEnd, \"Timelock not ended\");\r\n\r\n        bool approved = proposal.totalVotes > 0 && \r\n            isQuorumReached(proposal.yesVotes + proposal.noVotes);\r\n\r\n        if (approved) {\r\n            pool.approveClaimByDAO(claimId);\r\n        } else {\r\n            pool.rejectClaimByDAO(claimId);\r\n        }\r\n\r\n        activeProposalCount--;\r\n        \r\n        emit ProposalExecuted(\r\n            claimId,\r\n            approved,\r\n            proposal.yesVotes,\r\n            proposal.noVotes\r\n        );\r\n    }\r\n\r\n    function calculateVotingPower(address user) public view returns (uint256) {\r\n        (uint256 premiumPaid, ) = pool.users(user);\r\n        (uint256 stakedAmount, , , ) = pool.stakers(user);\r\n        uint256 userContribution = premiumPaid + stakedAmount;\r\n        \r\n        uint256 totalPoolSize = pool.totalPremiums() + pool.totalStaked() + pool.totalAppealFees();\r\n        if (totalPoolSize == 0) return 0;\r\n        \r\n        return (userContribution * 100) / totalPoolSize;\r\n    }\r\n\r\n    function isQuorumReached(uint256 totalVotes) internal view returns (bool) {\r\n        uint256 totalPossibleVotes = pool.totalPremiums() + pool.totalStaked();\r\n        return totalVotes * 100 >= totalPossibleVotes * QUORUM_PERCENTAGE;\r\n    }\r\n\r\n    function setAppealFee(uint256 newFee) external {\r\n        require(msg.sender == address(pool), \"Only pool can set fee\");\r\n        appealFee = newFee;\r\n    }\r\n\r\n    receive() external payable {}\r\n}"
    },
    "contracts/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./DAO.sol\";\r\n\r\ncontract Pool {\r\n    DAO public dao;\r\n    uint256 public constant TIMELOCK_DURATION = 2 days;\r\n    uint256 public totalAppealFees;\r\n\r\n    struct Plan {\r\n        uint256 id;\r\n        string name;\r\n        uint256 premium;\r\n        uint256 coverageAmount;\r\n    }\r\n\r\n    struct User {\r\n        uint256 totalPremiumPaid;\r\n        uint256 coverage;\r\n    }\r\n\r\n    struct Staker {\r\n        uint256 balance;\r\n        uint256 stakingTime;\r\n        uint256 lockDuration;\r\n        uint256 unlockTime;\r\n    }\r\n\r\n    struct Claim {\r\n        address claimant;\r\n        uint256 amount;\r\n        uint256 unlockTime;\r\n        ClaimStatus status;\r\n        string evidenceURI;\r\n        bool exists;\r\n    }\r\n\r\n    enum ClaimStatus { Timelock, DAO_Voting, Claimed, Rejected }\r\n\r\n    mapping(address => User) public users;\r\n    mapping(address => Staker) public stakers;\r\n    mapping(uint256 => Claim) public claims;\r\n    uint256 public claimCounter;\r\n    uint256 public totalPremiums;\r\n    uint256 public totalStaked;\r\n    Plan[] public plans;\r\n\r\n    event PremiumPaid(address indexed user, uint256 amount, uint256 coverage);\r\n    event ClaimInitiated(uint256 claimId, address indexed claimant, uint256 amount, uint256 unlockTime, string evidenceURI);\r\n    event ClaimApproved(uint256 claimId, address indexed claimant, uint256 amount);\r\n    event ClaimRejected(uint256 claimId);\r\n    event StakeDeposited(address indexed user, uint256 amount, uint256 lockDuration);\r\n    event StakeWithdrawn(address indexed user, uint256 amount, bool withInterest);\r\n\r\n    constructor() {\r\n        _addPlan(\"Basic Shield\", 0.01 ether, 5 ether);\r\n        _addPlan(\"Premium Guard\", 0.02 ether, 10 ether);\r\n        _addPlan(\"Ultimate Protection\", 0.03 ether, 20 ether);\r\n    }\r\n\r\n    function setDAO(address _daoAddress) external {\r\n        require(address(dao) == address(0), \"DAO already set\");\r\n        dao = DAO(payable(_daoAddress));\r\n    }\r\n\r\n    function _addPlan(string memory name, uint256 premium, uint256 coverageAmount) internal {\r\n        plans.push(Plan({\r\n            id: plans.length,\r\n            name: name,\r\n            premium: premium,\r\n            coverageAmount: coverageAmount\r\n        }));\r\n    }\r\n\r\n    function payPremium(uint256 planId) external payable {\r\n        require(planId < plans.length, \"Invalid plan ID\");\r\n        Plan memory plan = plans[planId];\r\n        require(msg.value == plan.premium, \"Incorrect premium amount\");\r\n\r\n        users[msg.sender].totalPremiumPaid += msg.value;\r\n        users[msg.sender].coverage = plan.coverageAmount;\r\n        totalPremiums += msg.value;\r\n\r\n        emit PremiumPaid(msg.sender, msg.value, plan.coverageAmount);\r\n    }\r\n\r\n    function submitClaim(uint256 amount, string memory evidenceURI, uint256 aiConfidence) external {\r\n        require(users[msg.sender].coverage >= amount, \"Insufficient coverage\");\r\n        \r\n        claimCounter++;\r\n        claims[claimCounter] = Claim({\r\n            claimant: msg.sender,\r\n            amount: amount,\r\n            unlockTime: block.timestamp + TIMELOCK_DURATION,\r\n            status: ClaimStatus.Timelock,\r\n            evidenceURI: evidenceURI,\r\n            exists: true\r\n        });\r\n\r\n        if (aiConfidence >= dao.AI_APPROVAL_THRESHOLD()) {\r\n            dao.createProposal(claimCounter, evidenceURI, aiConfidence);\r\n        }\r\n\r\n        emit ClaimInitiated(claimCounter, msg.sender, amount, block.timestamp + TIMELOCK_DURATION, evidenceURI);\r\n    }\r\n\r\n    function approveClaimByDAO(uint256 claimId) external {\r\n        require(msg.sender == address(dao), \"Only DAO can approve\");\r\n        Claim storage claim = claims[claimId];\r\n        require(claim.exists, \"Claim does not exist\");\r\n        require(claim.status == ClaimStatus.Timelock, \"Invalid claim status\");\r\n\r\n        claim.status = ClaimStatus.Claimed;\r\n        require(totalPremiums >= claim.amount, \"Insufficient premiums\");\r\n        totalPremiums -= claim.amount;\r\n        \r\n        (bool success, ) = payable(claim.claimant).call{value: claim.amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n\r\n        emit ClaimApproved(claimId, claim.claimant, claim.amount);\r\n    }\r\n\r\n    function rejectClaimByDAO(uint256 claimId) external {\r\n        require(msg.sender == address(dao), \"Only DAO can reject\");\r\n        Claim storage claim = claims[claimId];\r\n        require(claim.exists, \"Claim does not exist\");\r\n        claim.status = ClaimStatus.Rejected;\r\n        emit ClaimRejected(claimId);\r\n    }\r\n\r\n    function stake(uint256 duration) external payable {\r\n        require(msg.value > 0, \"Must stake something\");\r\n        require(\r\n            duration == 30 days || \r\n            duration == 180 days || \r\n            duration == 365 days, \r\n            \"Invalid duration\"\r\n        );\r\n        \r\n        stakers[msg.sender].balance += msg.value;\r\n        stakers[msg.sender].stakingTime = block.timestamp;\r\n        stakers[msg.sender].lockDuration = duration;\r\n        stakers[msg.sender].unlockTime = block.timestamp + duration;\r\n        totalStaked += msg.value;\r\n\r\n        emit StakeDeposited(msg.sender, msg.value, duration);\r\n    }\r\n\r\n    function unstake() external {\r\n        Staker storage staker = stakers[msg.sender];\r\n        require(staker.balance > 0, \"No stake to withdraw\");\r\n        \r\n        uint256 amount = staker.balance;\r\n        uint256 stakingDuration = block.timestamp - staker.stakingTime;\r\n        bool withInterest = stakingDuration >= staker.lockDuration;\r\n        \r\n        uint256 totalAmount = amount;\r\n        if (withInterest) {\r\n            totalAmount += _calculateInterest(amount, staker.lockDuration);\r\n        }\r\n        \r\n        staker.balance = 0;\r\n        staker.stakingTime = 0;\r\n        staker.lockDuration = 0;\r\n        staker.unlockTime = 0;\r\n        totalStaked -= amount;\r\n\r\n        (bool success, ) = payable(msg.sender).call{value: totalAmount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n\r\n        emit StakeWithdrawn(msg.sender, totalAmount, withInterest);\r\n    }\r\n\r\n    function _calculateInterest(uint256 amount, uint256 duration) internal pure returns (uint256) {\r\n        if (duration == 30 days) return (amount * 3) / 1000;\r\n        if (duration == 180 days) return (amount * 20) / 1000;\r\n        if (duration == 365 days) return (amount * 50) / 1000;\r\n        return 0;\r\n    }\r\n\r\n    receive() external payable {\r\n        require(msg.sender == address(dao), \"Only DAO can send funds\");\r\n        totalAppealFees += msg.value;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}